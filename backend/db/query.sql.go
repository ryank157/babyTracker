// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (event_type, event_time, notes, mood)
VALUES ($1, $2, $3, $4)
RETURNING event_id, event_type, event_time, notes, mood, created_at, updated_at
`

type CreateEventParams struct {
	EventType string
	EventTime pgtype.Timestamptz
	Notes     *string
	Mood      NullMoodType
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.EventType,
		arg.EventTime,
		arg.Notes,
		arg.Mood,
	)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.EventType,
		&i.EventTime,
		&i.Notes,
		&i.Mood,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFeedingEvent = `-- name: CreateFeedingEvent :execresult
INSERT INTO feeding_events (event_id, amount, feed_type, spitup, start_time, end_time, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateFeedingEventParams struct {
	EventID   int32
	Amount    pgtype.Numeric
	FeedType  NullFeedType
	Spitup    *bool
	StartTime pgtype.Timestamptz
	EndTime   pgtype.Timestamptz
	Notes     *string
}

func (q *Queries) CreateFeedingEvent(ctx context.Context, arg CreateFeedingEventParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createFeedingEvent,
		arg.EventID,
		arg.Amount,
		arg.FeedType,
		arg.Spitup,
		arg.StartTime,
		arg.EndTime,
		arg.Notes,
	)
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events
WHERE event_id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, eventID int32) error {
	_, err := q.db.Exec(ctx, deleteEvent, eventID)
	return err
}

const getEvent = `-- name: GetEvent :one
SELECT event_id, event_type, event_time, notes, mood, created_at, updated_at
FROM events
WHERE event_id = $1
`

func (q *Queries) GetEvent(ctx context.Context, eventID int32) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, eventID)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.EventType,
		&i.EventTime,
		&i.Notes,
		&i.Mood,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFeedingEventWithDetails = `-- name: GetFeedingEventWithDetails :one
SELECT
  e.event_id, e.event_type, e.event_time, e.notes, e.mood, e.created_at, e.updated_at,
  f.feeding_event_id, f.event_id, f.amount, f.feed_type, f.spitup, f.start_time, f.end_time, f.notes
FROM
  events e
JOIN
  feeding_events f ON e.event_id = f.event_id
WHERE
  e.event_type = 'Feeding' AND e.event_id = $1
`

type GetFeedingEventWithDetailsRow struct {
	EventID        int32
	EventType      string
	EventTime      pgtype.Timestamptz
	Notes          *string
	Mood           NullMoodType
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	FeedingEventID int32
	EventID_2      int32
	Amount         pgtype.Numeric
	FeedType       NullFeedType
	Spitup         *bool
	StartTime      pgtype.Timestamptz
	EndTime        pgtype.Timestamptz
	Notes_2        *string
}

func (q *Queries) GetFeedingEventWithDetails(ctx context.Context, eventID int32) (GetFeedingEventWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getFeedingEventWithDetails, eventID)
	var i GetFeedingEventWithDetailsRow
	err := row.Scan(
		&i.EventID,
		&i.EventType,
		&i.EventTime,
		&i.Notes,
		&i.Mood,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FeedingEventID,
		&i.EventID_2,
		&i.Amount,
		&i.FeedType,
		&i.Spitup,
		&i.StartTime,
		&i.EndTime,
		&i.Notes_2,
	)
	return i, err
}

const listDiaperEventsWithPoop = `-- name: ListDiaperEventsWithPoop :many
SELECT
e.event_id, e.event_type, e.event_time, e.notes, e.mood, e.created_at, e.updated_at,
d.diaper_event_id, d.event_id, d.poop, d.smell, d.size, d.softness, d.notes
FROM
events e
JOIN
diaper_events d ON e.event_id = d.event_id
WHERE
e.event_type = 'Diaper' AND d.poop = TRUE
ORDER BY e.event_time DESC
`

type ListDiaperEventsWithPoopRow struct {
	EventID       int32
	EventType     string
	EventTime     pgtype.Timestamptz
	Notes         *string
	Mood          NullMoodType
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DiaperEventID int32
	EventID_2     int32
	Poop          *bool
	Smell         NullDiaperSmellType
	Size          *string
	Softness      NullDiaperSoftnessType
	Notes_2       *string
}

func (q *Queries) ListDiaperEventsWithPoop(ctx context.Context) ([]ListDiaperEventsWithPoopRow, error) {
	rows, err := q.db.Query(ctx, listDiaperEventsWithPoop)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDiaperEventsWithPoopRow
	for rows.Next() {
		var i ListDiaperEventsWithPoopRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.EventTime,
			&i.Notes,
			&i.Mood,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DiaperEventID,
			&i.EventID_2,
			&i.Poop,
			&i.Smell,
			&i.Size,
			&i.Softness,
			&i.Notes_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByTypeAndTimeRange = `-- name: ListEventsByTypeAndTimeRange :many
SELECT event_id, event_type, event_time, notes, mood, created_at, updated_at
FROM events
WHERE event_type = $1
  AND event_time BETWEEN $2 AND $3
ORDER BY event_time DESC
`

type ListEventsByTypeAndTimeRangeParams struct {
	EventType   string
	EventTime   pgtype.Timestamptz
	EventTime_2 pgtype.Timestamptz
}

func (q *Queries) ListEventsByTypeAndTimeRange(ctx context.Context, arg ListEventsByTypeAndTimeRangeParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEventsByTypeAndTimeRange, arg.EventType, arg.EventTime, arg.EventTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.EventTime,
			&i.Notes,
			&i.Mood,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventNotes = `-- name: UpdateEventNotes :exec
UPDATE events
SET notes = $2
WHERE event_id = $1
`

type UpdateEventNotesParams struct {
	EventID int32
	Notes   *string
}

func (q *Queries) UpdateEventNotes(ctx context.Context, arg UpdateEventNotesParams) error {
	_, err := q.db.Exec(ctx, updateEventNotes, arg.EventID, arg.Notes)
	return err
}
